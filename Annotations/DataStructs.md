Data Structures and Algorithms
> Array -> Insert O(1), Search O(log N)
> Linked List -> Simply Linked List, Circular Linked List, Doubly Linked List
> Stack
> Queue
> Heap -> Complete Binary Tree which is used to store data efficiently to get the max or min element -> Max/Min Heap O(1) -> Insert, Delete O(log N)
> Hashing -> Key, Hash Function (hash func > hash index > hash table (Array)) -> Insert and search O(1) -> Worst case (Collision) O(n)
> Binary Tree -> A node and two leafs -> In worst case, O(n)
> Binary Search Tree (BST) -> Special case of Binary Tree that is balanced by value -> O(h), where h is the height of the BST.
> Trie or Prefix Tree -> Search - O(L) where L is the number of words in the query string


Big O notation
Reads O of ...
> O(1) -> Constant time - Random access of an element in an array, insert at the beginning of Linked List
> O(log n) -> Logarithmic time - Binary search
> O(n) -> Linear Time -> Looping through elements in an array, searching through a Linked List
> O(n log n) -> Quasilinear time -> Quicksort, MergeSort, HeapSort
> O(n^2) -> Quadratic time -> Insertion sort, Selection sort, Bubble sort
> O(n!) -> Factorial time -> Traveling Salesman problem